<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="udr-framework" xml:lang="ru">
  <info>
    <title>Структура UDR</title>
  </info>

  <para>Мы будем описывать структуру UDR на языке Pascal. Для объяснения минимальной структуры для
    построения UDR будем использовать стандартные примеры из <filename>examples/udr/</filename>
    переведённых на Pascal.</para>

  <para>Создайте новый проект новой динамической библиотеки,который назовём MyUdr. В результате у
    вас должен получиться файл <filename>MyUdr.dpr</filename> (если вы создавали проект в Delphi)
    или файл <filename>MyUdr.lpr</filename> (если вы создали проект в Lazarus). Теперь изменим
    главный файл проекта так чтобы он выглядел следующим образом: <programlisting language="delphi">
<![CDATA[            
library MyUdr;

{$IFDEF FPC}
  {$MODE DELPHI}{$H+}
{$ENDIF}

uses
{$IFDEF unix}
    cthreads,
    // the c memory manager is on some systems much faster for multi-threading
    cmem,
{$ENDIF}
  UdrInit in 'UdrInit.pas',
  SumArgsFunc in 'SumArgsFunc.pas';

exports firebird_udr_plugin;

end.     
]]>
    </programlisting>
  </para>


  <para>В данном случае необходимо экспортировать всего одну функцию
      <function>firebird_udr_plugin</function>, которая является точкой входа для плагина внешних
    модулей UDR. Реализация этой функции будет находится в модуле <package>UdrInit</package>.</para>
  <note>
    <title>Особенности Free Pascal</title>
    <para>Если вы разрабатываете вашу UDR в Free Pascal, то вам потребуются дополнительные
      директивы. Директива <code>{$mode objfpc}</code> требуется для включения режима Object Pascal.
      Вместо неё вы можете использовать директиву <code>{$mode delphi}</code> для обеспечения
      совместимости с Delphi. Поскольку мои примеры должны успешно компилироваться как в FPC, так и
      в Delphi я выбираю режим <code>{$mode delphi}</code>.</para>
    <para>Директива <code>{$H+}</code> включает поддержку длинных строк. Это необходимо если вы
      будете пользоваться типы string, ansistring, а не только нуль-терминированные строки PChar,
      PAnsiChar, PWideChar.</para>
    <para>Кроме того, нам потребуется подключить отдельные модули для поддержки многопоточности в
      Linux и других Unix-подобных операционных системах.</para>
  </note>

  <section xml:id="function-registration">

    <title>Регистрация функций</title>

    <para>Теперь добавим модуль UdrInit, он должен выглядеть следующим образом: <programlisting language="delphi">
<![CDATA[
unit UdrInit;

{$IFDEF FPC}
  {$MODE DELPHI}{$H+}
{$ENDIF}

interface

uses
  Firebird;

// точка входа для External Engine модуля UDR
function firebird_udr_plugin(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr;
  AUdrPlugin: IUdrPlugin): BooleanPtr; cdecl;

implementation

uses
  SumArgsFunc;

var
  myUnloadFlag: Boolean;
  theirUnloadFlag: BooleanPtr;

function firebird_udr_plugin(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr;
  AUdrPlugin: IUdrPlugin): BooleanPtr; cdecl;
begin
  // регистрируем наши функции
  AUdrPlugin.registerFunction(AStatus, 'sum_args',
    TSumArgsFunctionFactory.Create());
  // регистрируем наши процедуры
  //AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc',
  //  TSumArgsProcedureFactory.Create());
  //AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create());
  // регистрируем наши триггеры
  //AUdrPlugin.registerTrigger(AStatus, 'test_trigger',
  //  TMyTriggerFactory.Create());

  theirUnloadFlag := AUnloadFlagLocal;
  Result := @myUnloadFlag;
end;

initialization

myUnloadFlag := false;

finalization

if ((theirUnloadFlag <> nil) and not myUnloadFlag) then
  theirUnloadFlag^ := true;

end.
]]>            
             </programlisting>
    </para>

    <para>В функции <function>firebird_udr_plugin</function> необходимо зарегистрировать фабрики
      наших внешних процедур, функций и триггеров. Для каждой функции, процедуры или триггера
      необходимо написать свою фабрику. Это делается с помощью методов интерфейса
        <interfacename>IUdrPlugin</interfacename>:<itemizedlist spacing="compact">
        <listitem>
          <para><methodname>registerFunction</methodname> - регистрирует внешнюю функцию;</para>
        </listitem>
        <listitem>
          <para><methodname>registerProcedure</methodname> - регистрирует внешнюю процедуру;</para>
        </listitem>
        <listitem>
          <para><methodname>registerTrigger</methodname> - регистрирует внешний триггер.</para>
        </listitem>
      </itemizedlist></para>

    <para>Первым аргументом этих функций является указатель на статус вектор, далее следует
      внутреннее имя функции (процедуры или триггера). Внутреннее имя будет использоваться при
      создании процедуры/функции/триггера на SQL. Третьим аргументом передаётся экземпляр фабрики
      для создания функции (процедуры или триггера).</para>

  </section>

  <section xml:id="function-factory">

    <title>Фабрика функций</title>

    <para>Теперь необходимо написать фабрику и саму функцию. Они будут расположены в модуле
      SumArgsFunc. Примеры для написания процедур и триггеров будут представлены позже.</para>

    <para>
      <programlisting language="delphi">
<![CDATA[
unit SumArgsFunc;

{$IFDEF FPC}
{$MODE DELPHI}{$H+}
{$ENDIF}

interface

uses
  Firebird;

// *********************************************************
//    create function sum_args (
//      n1 integer,
//      n2 integer,
//      n3 integer
//    ) returns integer
//    external name 'myudr!sum_args'
//    engine udr;
// *********************************************************

type
  // структура на которое будет отображено входное сообщение
  TSumArgsInMsg = record
    n1: Integer;
    n1Null: WordBool;
    n2: Integer;
    n2Null: WordBool;
    n3: Integer;
    n3Null: WordBool;
  end;
  PSumArgsInMsg = ^TSumArgsInMsg;

  // структура на которое будет отображено выходное сообщение
  TSumArgsOutMsg = record
    result: Integer;
    resultNull: WordBool;
  end;
  PSumArgsOutMsg = ^TSumArgsOutMsg;

  // Фабрика для создания экземпляра внешней функции TSumArgsFunction
  TSumArgsFunctionFactory = class(IUdrFunctionFactoryImpl)
    // Вызывается при уничтожении фабрики
    procedure dispose(); override;

    { Выполняется каждый раз при загрузке внешней функции в кеш метаданных. 
      Используется для изменения формата входного и выходного сообщения.

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AMetadata Метаданные внешней функции)
      @param(AInBuilder Построитель сообщения для входных метаданных)
      @param(AOutBuilder Построитель сообщения для выходных метаданных)
    }
    procedure setup(AStatus: IStatus; AContext: IExternalContext;
      AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder;
      AOutBuilder: IMetadataBuilder); override;

    { Создание нового экземпляра внешней функции TSumArgsFunction

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AMetadata Метаданные внешней функции)
      @returns(Экземпляр внешней функции)
    }
    function newItem(AStatus: IStatus; AContext: IExternalContext;
      AMetadata: IRoutineMetadata): IExternalFunction; override;
  end;

  // Внешняя функция TSumArgsFunction.
  TSumArgsFunction = class(IExternalFunctionImpl)
    // Вызывается при уничтожении экземпляра функции
    procedure dispose(); override;

    { Этот метод вызывается непосредственно перед execute и сообщает
      ядру наш запрошенный набор символов для обмена данными внутри
      этого метода. Во время этого вызова контекст использует набор символов,
      полученный из ExternalEngine::getCharSet.

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AName Имя набора символов)
      @param(AName Длина имени набора символов)
    }
    procedure getCharSet(AStatus: IStatus; AContext: IExternalContext;
      AName: PAnsiChar; ANameSize: Cardinal); override;

    { Выполнение внешней функции

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AInMsg Указатель на входное сообщение)
      @param(AOutMsg Указатель на выходное сообщение)
    }
    procedure execute(AStatus: IStatus; AContext: IExternalContext;
      AInMsg: Pointer; AOutMsg: Pointer); override;
  end;

implementation

{ TSumArgsFunctionFactory }

procedure TSumArgsFunctionFactory.dispose;
begin
  Destroy;
end;

function TSumArgsFunctionFactory.newItem(AStatus: IStatus; 
  AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction;
begin
  Result := TSumArgsFunction.Create();
end;

procedure TSumArgsFunctionFactory.setup(AStatus: IStatus; 
  AContext: IExternalContext; AMetadata: IRoutineMetadata; 
  AInBuilder, AOutBuilder: IMetadataBuilder);
begin

end;

{ TSumArgsFunction }

procedure TSumArgsFunction.dispose;
begin
  Destroy;
end;

procedure TSumArgsFunction.execute(AStatus: IStatus; AContext: IExternalContext;
  AInMsg, AOutMsg: Pointer);
var
  xInput: PSumArgsInMsg;
  xOutput: PSumArgsOutMsg;
begin
  // преобразовываем указатели на вход и выход к типизированным
  xInput := PSumArgsInMsg(AInMsg);
  xOutput := PSumArgsOutMsg(AOutMsg);
  // если один из аргументов NULL значит и результат NULL
  xOutput^.resultNull := xInput^.n1Null or xInput^.n2Null or xInput^.n3Null;
  xOutput^.result := xInput^.n1 + xInput^.n2 + xInput^.n3; 
end;

procedure TSumArgsFunction.getCharSet(AStatus: IStatus;
  AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal);
begin
end;

end.
]]>            
             </programlisting>
    </para>

    <para>Фабрика внешней функции должна реализовать интерфейс
        <interfacename>IUdrFunctionFactory</interfacename>. Для упрощения просто наследуем класс
        <interfacename>IUdrFunctionFactoryImpl</interfacename>. Для каждой внешней функции нужна
      своя фабрика. Впрочем, если фабрики не имеют специфики для создания некоторой функции, то
      можно написать обобщённую фабрику с помощью дженериков. Позже мы приведём пример как это
      сделать.</para>

    <para>Метод <methodname>dispose</methodname> вызывается при уничтожении фабрики, в нём мы должны
      освободить ранее выделенные ресурсы. В данном случае просто вызываем деструктор.</para>

    <para>Метод <methodname>setup</methodname> выполняется каждый раз при загрузке внешней функции в
      кеш метаданных. В нём можно делать различные действия которые необходимы перед созданием
      экземпляра функции, например изменить формат для входных и выходных сообщений. Более подробно
      поговорим о нём позже.</para>


    <para>Метод <methodname>newItem</methodname> вызывается для создания экземпляра внешней функции.
      В этот метод передаётся указатель на статус вектор, контекст внешней функции и метаданные
      внешней функции. С помощью IRoutineMetadata вы можете получить формат входного и выходного
      сообщения, тело внешней функции и другие метаданные. В этом методе вы можете создавать
      различные экземпляры внешней функции в зависимости от её объявления в PSQL. Метаданные можно
      передать в созданный экземпляр внешней функции если это необходимо. В нашем случае мы просто
      создаём экземпляр внешней функции <classname>TSumArgsFunction</classname>.</para>

  </section>

  <section xml:id="function-instance">
    <title>Экземпляр функции</title>

    <para>Внешняя функция должна реализовать интерфейс
        <interfacename>IExternalFunction</interfacename>. Для упрощения просто наследуем класс
        <classname>IExternalFunctionImpl</classname>. </para>

    <para>Метод <methodname>dispose</methodname> вызывается при уничтожении экземпляра функции, в
      нём мы должны освободить ранее выделенные ресурсы. В данном случае просто вызываем
      деструктор.</para>

    <para>Метод <methodname>getCharSet</methodname> используется для того, чтобы сообщить внешней
      функции набор символов используемый при подключении к текущей базе данных. В большинстве
      случаев в этом нет необходимости, так как набор символов для входных и выходных переменных
      описан в метаданных при создании функции.</para>

    <para>Метод <methodname>execute</methodname> обрабатывает непосредственно сам вызов функции. В
      этот метод передаётся указатель на статус вектор, указатель на контекст внешней функции,
      указатели на входное и выходное сообщение.</para>

    <para>Контекст внешней функции может потребоваться нам для получения контекста текущего
      соединения или транзакции. Даже если вы не будете использовать запросы к базе данных в текущем
      соединении, то эти контексты всё равно могут потребоваться вам, особенно при работе с типом
      BLOB. Примеры работы с типом BLOB, а также использование контекстов соединения и транзакции
      будут показаны позже.</para>

    <para>Входные и выходные сообщения имеют фиксированную ширину, которая зависит от типов данных
      декларируемых для входных и выходных переменных соответственно. Это позволяет использовать
      типизированные указатели на структуры фиксированный ширины, члены который должны
      соответствовать типам данных. Из примера видно, что для каждой переменной в структуре
      указывается член соответствующего типа, после чего идёт член, который является признаком
      специального значения NULL (далее Null флаг). Помимо работы с буферами входных и выходных
      сообщений через структуры, существует ещё один способ с использованием адресной арифметики на
      указателях с использованием смещениях, значения которых можно получить из интерфейса
        <interfacename>IMessageMetadata</interfacename>. Подробнее о работе с сообщениями мы
      поговорим далее, а сейчас просто поясним что делалось в методе
        <methodname>execute</methodname>.</para>
    <para>Первым делом мы преобразовываем не типизированные указатели к типизированным. Для
      выходного значения устанавливаем Null флаг равный логическому объединению Null флагов у всех
      входных аргументов, если ни один из входных аргументов не равен NULL, то выходное значение
      будет равно сумме значений аргументов. </para>
  </section>

  <section xml:id="procedure-registration">
    <title>Регистрация процедур</title>

    <para>Пришло время добавить в наш UDR модуль хранимую процедуру. Как известно хранимые процедуры
      бывают двух видов: выполняемые хранимые процедуры и хранимые процедуры для выборки данных.
      Сначала добавим выполняемую хранимую процедуру, т.е. такую хранимую процедуру которая может
      быть вызвана с помощью оператора EXECUTE PROCEDURE и может вернуть не более одной
      записи.</para>

    <para>Вернитесь в модуль UdrInit и измените функцию <function>firebird_udr_plugin</function> так
      чтобы она выглядела следующим образом.</para>

    <para>
      <programlisting language="delphi">
        <![CDATA[
function firebird_udr_plugin(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr;
  AUdrPlugin: IUdrPlugin): BooleanPtr; cdecl;
begin
  // регистрируем наши функции
  AUdrPlugin.registerFunction(AStatus, 'sum_args',
    TSumArgsFunctionFactory.Create());
  // регистрируем наши процедуры
  AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc',
    TSumArgsProcedureFactory.Create());
  //AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create());
  // регистрируем наши триггеры
  //AUdrPlugin.registerTrigger(AStatus, 'test_trigger',
  //  TMyTriggerFactory.Create());

  theirUnloadFlag := AUnloadFlagLocal;
  Result := @myUnloadFlag;
end;        
        ]]>
      </programlisting>
    </para>

    <note>
      <para>Не забудьте добавить с список uses модуль SumArgsProc, в котором и будет расположена
        наша процедура.</para>
    </note>
  </section>
  <section xml:id="procedure-factory">
    <title>Фабрика процедур</title>

    <para>Фабрика внешней процедуры должна реализовать интерфейс
        <interfacename>IUdrProcedureFactory</interfacename>. Для упрощения просто наследуем класс
        <interfacename>IUdrProcedureFactoryImpl</interfacename>. Для каждой внешней процедуры нужна
      своя фабрика. Впрочем, если фабрики не имеют специфики для создания некоторой процедуры, то
      можно написать обобщённую фабрику с помощью дженериков. Позже мы приведём пример как это
      сделать.</para>

    <para>Метод <methodname>dispose</methodname> вызывается при уничтожении фабрики, в нём мы должны
      освободить ранее выделенные ресурсы. В данном случае просто вызываем деструктор.</para>

    <para>Метод <methodname>setup</methodname> выполняется каждый раз при загрузке внешней процедуры
      в кеш метаданных. В нём можно делать различные действия которые необходимы перед созданием
      экземпляра процедуры, например изменение формата для входных и выходных сообщений. Более
      подробно поговорим о нём позже.</para>

    <para>Метод <methodname>newItem</methodname> вызывается для создания экземпляра внешней
      процедуры. В этот метод передаётся указатель на статус вектор, контекст внешней процедуры и
      метаданные внешней процедуры. С помощью IRoutineMetadata вы можете получить формат входного и
      выходного сообщения, тело внешней функции и другие метаданные. В этом методе вы можете
      создавать различные экземпляры внешней функции в зависимости от её объявления в PSQL.
      Метаданные можно передать в созданный экземпляр внешней процедуры если это необходимо. В нашем
      случае мы просто создаём экземпляр внешней процедуры
      <classname>TSumArgsProcedure</classname>.</para>

    <para>Фабрику процедуры а также саму процедуру расположим в модуле SumArgsProc.</para>
    <para>
      <programlisting language="delphi">
        <![CDATA[
unit SumArgsProc;

{$IFDEF FPC}
{$MODE DELPHI}{$H+}
{$ENDIF}

interface

uses
  Firebird;

  { **********************************************************

    create procedure sp_sum_args (
      n1 integer,
      n2 integer,
      n3 integer
    ) returns (result integer)
    external name 'myudr!sum_args_proc'
    engine udr;

    ********************************************************* }
type
  // структура на которое будет отображено входное сообщение
  TSumArgsInMsg = record
    n1: Integer;
    n1Null: WordBool;
    n2: Integer;
    n2Null: WordBool;
    n3: Integer;
    n3Null: WordBool;
  end;
  PSumArgsInMsg = ^TSumArgsInMsg;

  // структура на которое будет отображено выходное сообщение
  TSumArgsOutMsg = record
    result: Integer;
    resultNull: WordBool;
  end;
  PSumArgsOutMsg = ^TSumArgsOutMsg;

  // Фабрика для создания экземпляра внешней процедуры TSumArgsProcedure
  TSumArgsProcedureFactory = class(IUdrProcedureFactoryImpl)
    // Вызывается при уничтожении фабрики
    procedure dispose(); override;

    { Выполняется каждый раз при загрузке внешней процедуры в кеш метаданных
      Используется для изменения формата входного и выходного сообщения.

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней процедуры)
      @param(AMetadata Метаданные внешней процедуры)
      @param(AInBuilder Построитель сообщения для входных метаданных)
      @param(AOutBuilder Построитель сообщения для выходных метаданных)
    }
    procedure setup(AStatus: IStatus; AContext: IExternalContext;
      AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder;
      AOutBuilder: IMetadataBuilder); override;

    { Создание нового экземпляра внешней процедуры TSumArgsProcedure

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней процедуры)
      @param(AMetadata Метаданные внешней процедуры)
      @returns(Экземпляр внешней процедуры)
    }
    function newItem(AStatus: IStatus; AContext: IExternalContext;
      AMetadata: IRoutineMetadata): IExternalProcedure; override;
  end;

  TSumArgsProcedure = class(IExternalProcedureImpl)
  public
    // Вызывается при уничтожении экземпляра процедуры
    procedure dispose(); override;

    { Этот метод вызывается непосредственно перед open и сообщает
      ядру наш запрошенный набор символов для обмена данными внутри
      этого метода. Во время этого вызова контекст использует набор символов,
      полученный из ExternalEngine::getCharSet.

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AName Имя набора символов)
      @param(AName Длина имени набора символов)
    }
    procedure getCharSet(AStatus: IStatus; AContext: IExternalContext;
      AName: PAnsiChar; ANameSize: Cardinal); override;

    { Выполнение внешней процедуры

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AInMsg Указатель на входное сообщение)
      @param(AOutMsg Указатель на выходное сообщение)
      @returns(Набор данных для селективной процедуры или 
               nil для процедур выполнения)
    }
    function open(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer;
      AOutMsg: Pointer): IExternalResultSet; override;
  end;

implementation

{ TSumArgsProcedureFactory }

procedure TSumArgsProcedureFactory.dispose;
begin
  Destroy;
end;

function TSumArgsProcedureFactory.newItem(AStatus: IStatus;
  AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure;
begin
  Result := TSumArgsProcedure.create;
end;

procedure TSumArgsProcedureFactory.setup(AStatus: IStatus;
  AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder,
  AOutBuilder: IMetadataBuilder);
begin

end;

{ TSumArgsProcedure }

procedure TSumArgsProcedure.dispose;
begin
  Destroy;
end;

procedure TSumArgsProcedure.getCharSet(AStatus: IStatus;
  AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal);
begin

end;

function TSumArgsProcedure.open(AStatus: IStatus; AContext: IExternalContext;
  AInMsg, AOutMsg: Pointer): IExternalResultSet;
var
  xInput: PSumArgsInMsg;
  xOutput: PSumArgsOutMsg;
begin
  Result := nil;
  // преобразовываем указатели на вход и выход к типизированным
  xInput := PSumArgsInMsg(AInMsg);
  xOutput := PSumArgsOutMsg(AOutMsg);
  // если один из аргументов NULL значит и результат NULL
  xOutput^.resultNull := xInput^.n1Null or xInput^.n2Null or xInput^.n3Null;
  xOutput^.result := xInput^.n1 + xInput^.n2 + xInput^.n3;
end;

end.      
        ]]>
      </programlisting>
    </para>
  </section>
  <section xml:id="procedure-instance">
    <title>Экземпляр процедуры</title>
    <para>Внешняя процедура должна реализовать интерфейс
        <interfacename>IExternalProcedure</interfacename>. Для упрощения просто наследуем класс
        <classname>IExternalProcedureImpl</classname>. </para>
    <para>Метод <methodname>dispose</methodname> вызывается при уничтожении экземпляра процедуры, в
      нём мы должны освободить ранее выделенные ресурсы. В данном случае просто вызываем
      деструктор.</para>
    <para>Метод <methodname>getCharSet</methodname> используется для того чтобы сообщить внешней
      процедуре набор символов используемый при подключении к текущей базе данных. В большинстве
      случаев в этом нет необходимости, так как набор символов для входных и выходных переменных
      описан в метаданных при создании процедуры.</para>

    <para>Метод <methodname>open</methodname> обрабатывает непосредственно сам вызов процедуры. В
      этот метод передаётся указатель на статус вектор, указатель на контекст внешней функции,
      указатели на входное и выходное сообщение. Если у вас выполняемая процедура, то метод должен
      вернуть значение nil, в противном случае должен вернуться экземпляр набора выходных данных для
      процедуры. В данном случае нам не нужно создавать экземпляр набора данных. Просто переносим
      логику из метода <methodname>TSumArgsFunction.execute</methodname>.</para>
  </section>

  <section xml:id="procedure-selectable">
    <title>Хранимая процедура выбора</title>

    <para>Теперь добавим в наш UDR модуль простую процедуру выбора. Для этого изменим функцию
      регистрации <function>firebird_udr_plugin</function>. </para>

    <para>
      <programlisting language="delphi">
        <![CDATA[
function firebird_udr_plugin(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr;
  AUdrPlugin: IUdrPlugin): BooleanPtr; cdecl;
begin
  // регистрируем наши функции
  AUdrPlugin.registerFunction(AStatus, 'sum_args',
    TSumArgsFunctionFactory.Create());
  // регистрируем наши процедуры
  AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc',
    TSumArgsProcedureFactory.Create());
  AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create());
  // регистрируем наши триггеры
  //AUdrPlugin.registerTrigger(AStatus, 'test_trigger',
  //  TMyTriggerFactory.Create());

  theirUnloadFlag := AUnloadFlagLocal;
  Result := @myUnloadFlag;
end;        
        ]]>
      </programlisting>
    </para>

    <note>
      <para>Не забудьте добавить с список uses модуль GenRowsProc, в котором и будет расположена
        наша процедура.</para>
    </note>

    <para>Фабрика процедур полностью идентична как для случая с выполняемой хранимой процедурой.
      Методы экземпляра процедуры тоже идентичны, за исключением метода
        <methodname>open</methodname>, который разберём чуть подробнее.</para>

    <para>
      <programlisting language="delphi">
        <![CDATA[
unit GenRowsProc;

{$IFDEF FPC}
{$MODE DELPHI}{$H+}
{$ENDIF}

interface

uses
  Firebird, SysUtils;

type
  { **********************************************************

    create procedure gen_rows (
      start  integer,
      finish integer
    ) returns (n integer)
    external name 'myudr!gen_rows'
    engine udr;

    ********************************************************* }

  TInput = record
    start: Integer;
    startNull: WordBool;
    finish: Integer;
    finishNull: WordBool;
  end;
  PInput = ^TInput;

  TOutput = record
    n: Integer;
    nNull: WordBool;
  end;
  POutput = ^TOutput;

  // Фабрика для создания экземпляра внешней процедуры TGenRowsProcedure
  TGenRowsFactory = class(IUdrProcedureFactoryImpl)
    // Вызывается при уничтожении фабрики
    procedure dispose(); override;

    { Выполняется каждый раз при загрузке внешней функции в кеш метаданных.
      Используется для изменения формата входного и выходного сообщения.

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AMetadata Метаданные внешней функции)
      @param(AInBuilder Построитель сообщения для входных метаданных)
      @param(AOutBuilder Построитель сообщения для выходных метаданных)
    }
    procedure setup(AStatus: IStatus; AContext: IExternalContext;
      AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder;
      AOutBuilder: IMetadataBuilder); override;

    { Создание нового экземпляра внешней процедуры TGenRowsProcedure

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AMetadata Метаданные внешней функции)
      @returns(Экземпляр внешней функции)
    }
    function newItem(AStatus: IStatus; AContext: IExternalContext;
      AMetadata: IRoutineMetadata): IExternalProcedure; override;
  end;

  // Внешняя процедура TGenRowsProcedure.
  TGenRowsProcedure = class(IExternalProcedureImpl)
  public
    // Вызывается при уничтожении экземпляра процедуры
    procedure dispose(); override;

    { Этот метод вызывается непосредственно перед open и сообщает
      ядру наш запрошенный набор символов для обмена данными внутри
      этого метода. Во время этого вызова контекст использует набор символов,
      полученный из ExternalEngine::getCharSet.

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AName Имя набора символов)
      @param(AName Длина имени набора символов)
    }
    procedure getCharSet(AStatus: IStatus; AContext: IExternalContext;
      AName: PAnsiChar; ANameSize: Cardinal); override;

    { Выполнение внешней процедуры

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешней функции)
      @param(AInMsg Указатель на входное сообщение)
      @param(AOutMsg Указатель на выходное сообщение)
      @returns(Набор данных для селективной процедуры или 
               nil для процедур выполнения)
    }
    function open(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer;
      AOutMsg: Pointer): IExternalResultSet; override;
  end;

  // Выходной набор данных для процедуры TGenRowsProcedure
  TGenRowsResultSet = class(IExternalResultSetImpl)
    Input: PInput;
    Output: POutput;

    // Вызывается при уничтожении экземпляра набора данных
    procedure dispose(); override;

    { Извлечение очередной записи из набора данных.
      В некотором роде аналог SUSPEND. В этом методе должна
      подготавливаться очередная запись из набора данных.

      @param(AStatus Статус вектор)
      @returns(True если в наборе данных есть запись для извлечения,
               False если записи закончились)
    }
    function fetch(AStatus: IStatus): Boolean; override;
  end;

implementation

{ TGenRowsFactory }

procedure TGenRowsFactory.dispose;
begin
  Destroy;
end;

function TGenRowsFactory.newItem(AStatus: IStatus; AContext: IExternalContext;
  AMetadata: IRoutineMetadata): IExternalProcedure;
begin
  Result := TGenRowsProcedure.create;
end;

procedure TGenRowsFactory.setup(AStatus: IStatus; AContext: IExternalContext;
  AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder);
begin

end;

{ TGenRowsProcedure }

procedure TGenRowsProcedure.dispose;
begin
  Destroy;
end;

procedure TGenRowsProcedure.getCharSet(AStatus: IStatus;
  AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal);
begin

end;

function TGenRowsProcedure.open(AStatus: IStatus; AContext: IExternalContext;
  AInMsg, AOutMsg: Pointer): IExternalResultSet;
begin
  // если один из входных аргументов NULL ничего не возвращаем
  if PInput(AInMsg).startNull or PInput(AInMsg).finishNull then
  begin
    POutput(AOutMsg).nNull := True;
    Result := nil;
    exit;
  end;
  // проверки
  if PInput(AInMsg).start > PInput(AInMsg).finish then
    raise Exception.Create('First parameter greater then second parameter.');

  Result := TGenRowsResultSet.create;
  with TGenRowsResultSet(Result) do
  begin
    Input := AInMsg;
    Output := AOutMsg;
    // начальное значение
    Output.nNull := False;
    Output.n := Input.start - 1;
  end;
end;

{ TGenRowsResultSet }

procedure TGenRowsResultSet.dispose;
begin
  Destroy;
end;

// Если возвращает True то извлекается очередная запись из набора данных.
// Если возвращает False то записи в наборе данных закончились
// новые значения в выходном векторе вычисляются каждый раз 
// при вызове этого метода
function TGenRowsResultSet.fetch(AStatus: IStatus): Boolean;
begin
  Inc(Output.n);
  Result := (Output.n <= Input.finish);
end;

end.        
        ]]>
      </programlisting>
    </para>
    <para>В методе <methodname>open</methodname> экземпляра процедуры
        <classname>TGenRowsProcedure</classname> проверяем первый и второй входной аргумент на
      значение NULL, если один из аргументов равен NULL, то и выходной аргумент равен NULL, кроме
      того процедура не должна вернуть ни одной строки при выборке через оператор SELECT, поэтому
      результатом этого метода будет nil.</para>
    <para>Кроме того мы проверяем, чтобы первый аргумент не превышал значение второго, в противном
      случае бросаем исключение. Не волнуйтесь это исключение будет перехвачено в подсистеме UDR и
      преобразовано к исключению Firebird. Это одно из преимуществ новых UDR перед Legacy
      UDF.</para>
    <para>Поскольку мы создаём процедуру выбора, то метод <methodname>open</methodname> должен
      возвращать экземпляр набора данных, который реализует интерфейс
        <interfacename>IExternalResultSet</interfacename>. Для упрощения унаследуем свой набор
      данных от класса <classname>IExternalResultSetImpl</classname>.</para>
    <para>Метод <methodname>dispose</methodname> предназначен для освобождения выделенных ресурсов.
      В нём мы просто вызываем деструктор.</para>
    <para>Метод <methodname>fetch</methodname> вызывается при извлечении очередной записи оператором
      SELECT. Этот метод по сути является аналогом оператора SUSPEND используемый в обычных PSQL
      хранимых процедурах. Каждый раз когда он вызывается, в нём подготавливаются новые значения для
      выходного сообщения. Метод возвращает true, если запись должна быть возвращена вызывающей
      стороне, и <literal>false</literal>, если данных для извлечения больше нет. В нашем случае мы
      просто инкрементируем текущее значение выходной переменной до тех пор, пока оно не больше
      максимальной границы.</para>

    <note>
      <para>В Delphi нет поддержки оператора yeild, таким образом у вас не получится написать код
        вроде <programlisting language="cpp">
<![CDATA[
while(...) do {
  ...
  yield result;
} 
]]>             
         </programlisting>
      </para>
      <para>Вы можете использовать любой класс коллекции, заполнить его в методе
          <methodname>open</methodname>, хранимой процедуры, и затем поэлементно возвращать значения
        из этой коллекции в <methodname>fetch</methodname>. Однако в этом случае вы лишаетесь
        возможности досрочно прервать выполнение процедуры (неполный фетч в SELECT или ограничители
        FIRST/ROWS/FETCH FIRST в операторе SELECT.)</para>
    </note>
  </section>
  <section xml:id="trigger-registration">
    <title>Регистрация триггеров</title>

    <para>Теперь добавим в наш UDR модуль внешний триггер.</para>

    <note>
      <para>В оригинальных примерах на C++ триггер копирует запись в другую внешнюю базу данных. Я
        считаю, что такой пример излишне сложен для первого ознакомления с внешними триггерами.
        Работа с подключениями к внешним базам данных будет рассмотрен позже.</para>
    </note>

    <para>Вернитесь в модуль UdrInit и измените функцию <function>firebird_udr_plugin</function> так
      чтобы она выглядела следующим образом.</para>

    <para>
      <programlisting language="delphi">
<![CDATA[
function firebird_udr_plugin(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr;
  AUdrPlugin: IUdrPlugin): BooleanPtr; cdecl;
begin
  // регистрируем наши функции
  AUdrPlugin.registerFunction(AStatus, 'sum_args',
    TSumArgsFunctionFactory.Create());
  // регистрируем наши процедуры
  AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc',
    TSumArgsProcedureFactory.Create());
  AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create());
  // регистрируем наши триггеры
  AUdrPlugin.registerTrigger(AStatus, 'test_trigger',
    TMyTriggerFactory.Create());

  theirUnloadFlag := AUnloadFlagLocal;
  Result := @myUnloadFlag;
end;
]]>        
      </programlisting>
    </para>

    <note>
      <para>Не забудьте добавить с список uses модуль TestTrigger, в котором и будет расположен наш
        триггер.</para>
    </note>
  </section>
  <section xml:id="trigger-factory">
    <title>Фабрика триггеров</title>

    <para>Фабрика внешнего триггера должна реализовать интерфейс
        <interfacename>IUdrTriggerFactory</interfacename>. Для упрощения просто наследуем класс
        <interfacename>IUdrTriggerFactoryImpl</interfacename>. Для каждого внешнего триггера нужна
      своя фабрика.</para>

    <para>Метод <methodname>dispose</methodname> вызывается при уничтожении фабрики, в нём мы должны
      освободить ранее выделенные ресурсы. В данном случае просто вызываем деструктор.</para>

    <para>Метод <methodname>setup</methodname> выполняется каждый раз при загрузке внешнего триггера
      в кеш метаданных. В нём можно делать различные действия которые необходимы перед созданием
      экземпляра триггера, например для изменения формата сообщений для полей таблицы. Более
      подробно поговорим о нём позже.</para>

    <para>Метод <methodname>newItem</methodname> вызывается для создания экземпляра внешнего
      триггера. В этот метод передаётся указатель на статус вектор, контекст внешнего триггера и
      метаданные внешнего триггера. С помощью IRoutineMetadata вы можете получить формат сообщения
      для новых и старых значений полей, тело внешнего триггера и другие метаданные. В этом методе
      вы можете создавать различные экземпляры внешнего триггера в зависимости от его объявления в
      PSQL. Метаданные можно передать в созданный экземпляр внешнего триггера если это необходимо. В
      нашем случае мы просто создаём экземпляр внешнего триггера
      <classname>TMyTrigger</classname>.</para>

    <para>Фабрику триггера а также сам триггер расположим в модуле TestTrigger.</para>
    <para>
      <programlisting language="delphi">
<![CDATA[
unit TestTrigger;

{$IFDEF FPC}
{$MODE DELPHI}{$H+}
{$ENDIF}

interface

uses
  Firebird, SysUtils;

type
  { **********************************************************
    create table test (
      id int generated by default as identity,
      a int,
      b int,
      name varchar(100),
      constraint pk_test primary key(id)
    );

    create or alter trigger tr_test_biu for test
    active before insert or update position 0
    external name 'myudr!test_trigger'
    engine udr;
  }

  // структура для отображения сообщений NEW.* и OLD.*
  // должна соответствовать набору полей таблицы test
  TFieldsMessage = record
    Id: Integer;
    IdNull: WordBool;
    A: Integer;
    ANull: WordBool;
    B: Integer;
    BNull: WordBool;
    Name: record
      Length: Word;
      Value: array [0 .. 399] of AnsiChar;
    end;
    NameNull: WordBool;
  end;

  PFieldsMessage = ^TFieldsMessage;

  // Фабрика для создания экземпляра внешнего триггера TMyTrigger
  TMyTriggerFactory = class(IUdrTriggerFactoryImpl)
    // Вызывается при уничтожении фабрики
    procedure dispose(); override;

    { Выполняется каждый раз при загрузке внешнего триггера в кеш метаданных.
      Используется для изменения формата сообщений для полей.

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешнего триггера)
      @param(AMetadata Метаданные внешнего триггера)
      @param(AFieldsBuilder Построитель сообщения для полей таблицы)
    }
    procedure setup(AStatus: IStatus; AContext: IExternalContext;
      AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder); override;

    { Создание нового экземпляра внешнего триггера TMyTrigger

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешнего триггера)
      @param(AMetadata Метаданные внешнего триггера)
      @returns(Экземпляр внешнего триггера)
    }
    function newItem(AStatus: IStatus; AContext: IExternalContext;
      AMetadata: IRoutineMetadata): IExternalTrigger; override;
  end;

  TMyTrigger = class(IExternalTriggerImpl)
    // Вызывается при уничтожении триггера
    procedure dispose(); override;

    { Этот метод вызывается непосредственно перед execute и сообщает
      ядру наш запрошенный набор символов для обмена данными внутри
      этого метода. Во время этого вызова контекст использует набор символов,
      полученный из ExternalEngine::getCharSet.

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешнего триггера)
      @param(AName Имя набора символов)
      @param(AName Длина имени набора символов)
    }
    procedure getCharSet(AStatus: IStatus; AContext: IExternalContext;

      AName: PAnsiChar; ANameSize: Cardinal); override;

    { выполнение триггера TMyTrigger

      @param(AStatus Статус вектор)
      @param(AContext Контекст выполнения внешнего триггера)
      @param(AAction Действие (текущее событие) триггера)
      @param(AOldMsg Сообщение для старых значение полей :OLD.*)
      @param(ANewMsg Сообщение для новых значение полей :NEW.*)
    }
    procedure execute(AStatus: IStatus; AContext: IExternalContext;
      AAction: Cardinal; AOldMsg: Pointer; ANewMsg: Pointer); override;
  end;

implementation

{ TMyTriggerFactory }

procedure TMyTriggerFactory.dispose;
begin
  Destroy;
end;

function TMyTriggerFactory.newItem(AStatus: IStatus; AContext: IExternalContext;
  AMetadata: IRoutineMetadata): IExternalTrigger;
begin
  Result := TMyTrigger.create;
end;

procedure TMyTriggerFactory.setup(AStatus: IStatus; AContext: IExternalContext;
  AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder);
begin

end;

{ TMyTrigger }

procedure TMyTrigger.dispose;
begin
  Destroy;
end;

procedure TMyTrigger.execute(AStatus: IStatus; AContext: IExternalContext;
  AAction: Cardinal; AOldMsg, ANewMsg: Pointer);
var
  xOld, xNew: PFieldsMessage;
begin
  // xOld := PFieldsMessage(AOldMsg);
  xNew := PFieldsMessage(ANewMsg);
  case AAction of
    IExternalTrigger.ACTION_INSERT:
      begin
        if xNew.BNull and not xNew.ANull then
        begin
          xNew.B := xNew.A + 1;
          xNew.BNull := False;
        end;
      end;

    IExternalTrigger.ACTION_UPDATE:
      begin
        if xNew.BNull and not xNew.ANull then
        begin
          xNew.B := xNew.A + 1;
          xNew.BNull := False;
        end;
      end;

    IExternalTrigger.ACTION_DELETE:
      begin

      end;
  end;
end;

procedure TMyTrigger.getCharSet(AStatus: IStatus; AContext: IExternalContext;
  AName: PAnsiChar; ANameSize: Cardinal);
begin

end;

end.        
]]>
      </programlisting>
    </para>
  </section>
  <section xml:id="trigger-instance">
    <title>Экземпляр триггера</title>
    <para>Внешний триггер должна реализовать интерфейс
        <interfacename>IExternalTrigger</interfacename>. Для упрощения просто наследуем класс
        <classname>IExternalTriggerImpl</classname>. </para>
    <para>Метод <methodname>dispose</methodname> вызывается при уничтожении экземпляра триггера, в
      нём мы должны освободить ранее выделенные ресурсы. В данном случае просто вызываем
      деструктор.</para>
    <para>Метод <methodname>getCharSet</methodname> используется для того чтобы сообщить внешнему
      триггеру набор символов используемый при подключении к текущей базе данных. В большинстве
      случаев в этом нет необходимости, так как набор символов для полей таблицы описан в метаданных
      таблицы.</para>
    <para>Метод <methodname>execute</methodname> вызывается при выполнении триггера на одно из
      событий для которого создан триггер. В этот метод передаётся указатель на статус вектор,
      указатель на контекст внешнего триггера, действие (событие) которое вызвало срабатывание
      триггера и указатели на сообщения для старых и новых значений полей. Возможные действия
      (события) триггера перечислены константами в интерфейсе
        <interfacename>IExternalTrigger</interfacename>. Такие константы начинаются с префикса
        <literal>ACTION_</literal>. Знания о текущем действие необходимо, поскольку в Firebird
      существуют триггеры созданные для нескольких событий сразу. Сообщения необходимы только для
      триггеров на действия таблицы, для DDL триггеров, а для триггеров на события подключения,
      отключения от базы данных и триггеров на события старта, завершения и отката транзакции
      указатели на сообщения будут инициализированы значением nil. В отличие от процедур и функций
      сообщения триггеров строятся для полей таблицы на события которой создан триггер. Статические
      структуры для таких сообщений строятся по тем же принципам, что и структуры сообщений для
      входных и выходных параметров процедуры, только вместо переменных берутся поля таблицы.</para>
    <note>
      <para>Обратите внимание, что если вы используете отображение сообщений на структуры, то ваши
        триггеры могут сломаться после изменения состава полей таблицы и их типов. Чтобы этого не
        произошло используйте работу с сообщение через смещения получаемые из
          <interfacename>IMessageMetadata</interfacename>. Это не так актуально для процедур и
        функций, поскольку входные и выходные параметры меняются не так уж часто. Или хотя бы вы
        делаете это явно, что может натолкнуть вас на мысль, что необходимо переделать и внешнюю
        процедуру/функцию.</para>
    </note>
    <para>В нашем простейшем триггере мы определяем тип события, и в теле триггера выполняем
      следующий PSQL аналог
      <programlisting language="sql">
...
  if (:new.B IS NULL) THEN
    :new.B = :new.A + 1;
...
    </programlisting>
    </para>
  </section>
</chapter>
